"""
Sandbox artifact persistence & serving.

Sandbox outputs (images, CSVs, text files, â€¦) are written directly to disk by
the sandbox tool under ``<DATA_PATH>/sandbox_artifacts/<trace_id>/`` and served
via a dedicated Flask route.  The response text contains only lightweight
markdown links/images that the frontend resolves to that route.

Design goals
------------
* **Plug-and-play** â€“ if the sandbox tool is not installed or no artifacts are
  produced, nothing here runs.  No config flag needed.
* **No cross-contamination** â€“ every trace gets its own directory, keyed by
  the UUID ``trace_id`` already generated by the streaming layer.
* **Arbitrary file types** â€“ images get ``![](â€¦)`` markdown; everything else
  gets a download link.  The frontend ``sandbox-artifacts.js`` module adds
  richer rendering (inline preview for images, download buttons for others).

TODO: add a periodic cleanup job or TTL-based reaper for old artifact dirs.
"""

from __future__ import annotations

import mimetypes
import os
import re
from pathlib import Path
from typing import Dict, List, Tuple

from src.utils.logging import get_logger

logger = get_logger(__name__)

# Allowed characters in filenames served back to clients (security).
_SAFE_FILENAME_RE = re.compile(r"^[\w\-. ]+$")

# Mime-type families that the frontend can display inline.
_IMAGE_MIMETYPES = frozenset({
    "image/png", "image/jpeg", "image/gif", "image/webp", "image/svg+xml",
})


def _artifacts_root(data_path: str) -> Path:
    """Return the top-level artifacts directory, creating it if needed."""
    root = Path(data_path) / "sandbox_artifacts"
    root.mkdir(parents=True, exist_ok=True)
    return root


def _trace_dir(data_path: str, trace_id: str) -> Path:
    """Return the per-trace artifact directory, creating it if needed."""
    # Validate trace_id looks like a UUID to prevent path traversal.
    if not re.fullmatch(r"[0-9a-f\-]{36}", trace_id):
        raise ValueError(f"Invalid trace_id: {trace_id!r}")
    d = _artifacts_root(data_path) / trace_id
    d.mkdir(parents=True, exist_ok=True)
    return d


def _sanitize_filename(filename: str) -> str:
    """
    Sanitize a filename for safe storage â€” strip path separators, reject
    suspicious patterns.  Returns the cleaned name or raises ValueError.
    """
    name = os.path.basename(filename).strip()
    if not name or not _SAFE_FILENAME_RE.match(name):
        raise ValueError(f"Unsafe filename: {filename!r}")
    return name


# -------------------------------------------------------------------------
# Public API
# -------------------------------------------------------------------------

def format_artifacts_markdown(artifacts: List[Dict]) -> str:
    """
    Build markdown text referencing persisted artifacts.

    Parameters
    ----------
    artifacts : list[dict]
        Artifact metadata dicts from ``get_sandbox_artifacts()``.  Each dict
        has keys ``filename``, ``mimetype``, and ``url``.

    Returns
    -------
    str
        Markdown block with images and/or download links.
        Images â†’ ``![filename](url)``
        Other files â†’ ``[ðŸ“Ž filename](url)``
    """
    if not artifacts:
        return ""

    parts: List[str] = []
    for art in artifacts:
        mime = art.get("mimetype", "")
        fname = art["filename"]
        url = art["url"]

        if mime in _IMAGE_MIMETYPES:
            parts.append(f"![{fname}]({url})")
        else:
            parts.append(f"[ðŸ“Ž {fname}]({url})")

    return "\n\n" + "\n\n".join(parts)


# -------------------------------------------------------------------------
# Flask route handler
# -------------------------------------------------------------------------

def serve_artifact(data_path: str, trace_id: str, filename: str) -> Tuple:
    """
    Serve an artifact file from disk.

    Returns a ``(response_body, status, headers)`` tuple suitable for Flask,
    or a JSON error tuple on failure.
    """
    try:
        safe_name = _sanitize_filename(filename)
    except ValueError:
        return ({"error": "invalid filename"}, 400)

    try:
        tdir = _trace_dir(data_path, trace_id)
    except ValueError:
        return ({"error": "invalid trace_id"}, 400)

    filepath = tdir / safe_name
    if not filepath.is_file():
        return ({"error": "not found"}, 404)

    # Resolve to prevent symlink escape
    resolved = filepath.resolve()
    if not str(resolved).startswith(str(tdir.resolve())):
        return ({"error": "access denied"}, 403)

    mime = mimetypes.guess_type(safe_name)[0] or "application/octet-stream"

    # For images, allow inline display; for everything else, suggest download.
    disposition = "inline" if mime in _IMAGE_MIMETYPES else f'attachment; filename="{safe_name}"'

    data = resolved.read_bytes()
    return (
        data,
        200,
        {
            "Content-Type": mime,
            "Content-Disposition": disposition,
            "Cache-Control": "private, max-age=3600",
            "Content-Length": str(len(data)),
        },
    )
