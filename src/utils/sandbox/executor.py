"""
Sandbox executor for running code in isolated Docker containers.

This module provides the SandboxExecutor class that manages ephemeral container
lifecycle for secure code execution.
"""

from __future__ import annotations

import base64
import io
import os
import tarfile
import tempfile
import time
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Dict, List, Optional

from src.utils.logging import get_logger
from src.utils.sandbox.config import ResourceLimits, SandboxConfig

logger = get_logger(__name__)


# Language to execution command mapping
LANGUAGE_COMMANDS = {
    "python": ["python", "/workspace/script.py"],
    "python3": ["python3", "/workspace/script.py"],
    "bash": ["bash", "/workspace/script.sh"],
    "sh": ["sh", "/workspace/script.sh"],
}

# Language to file extension mapping
LANGUAGE_EXTENSIONS = {
    "python": ".py",
    "python3": ".py",
    "bash": ".sh",
    "sh": ".sh",
}


@dataclass
class FileOutput:
    """Represents a file generated by sandbox execution."""
    
    filename: str
    """Name of the file."""
    
    mimetype: str
    """MIME type of the file."""
    
    content_base64: str
    """Base64-encoded file content."""
    
    size: int
    """Size of the file in bytes."""
    
    truncated: bool = False
    """Whether the file was truncated due to size limits."""


@dataclass
class SandboxResult:
    """Result of a sandbox code execution."""
    
    stdout: str = ""
    """Captured standard output."""
    
    stderr: str = ""
    """Captured standard error."""
    
    exit_code: int = 0
    """Process exit code."""
    
    execution_time: float = 0.0
    """Execution time in seconds."""
    
    files: List[FileOutput] = field(default_factory=list)
    """Generated output files."""
    
    truncated: bool = False
    """Whether stdout/stderr was truncated."""
    
    error: Optional[str] = None
    """Error message if execution failed (not a code error, but system error)."""
    
    timed_out: bool = False
    """Whether execution timed out."""
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "stdout": self.stdout,
            "stderr": self.stderr,
            "exit_code": self.exit_code,
            "execution_time": self.execution_time,
            "files": [
                {
                    "filename": f.filename,
                    "mimetype": f.mimetype,
                    "content_base64": f.content_base64,
                    "size": f.size,
                    "truncated": f.truncated,
                }
                for f in self.files
            ],
            "truncated": self.truncated,
            "error": self.error,
            "timed_out": self.timed_out,
        }


def _guess_mimetype(filename: str) -> str:
    """Guess MIME type from filename extension."""
    ext = Path(filename).suffix.lower()
    mime_map = {
        ".png": "image/png",
        ".jpg": "image/jpeg",
        ".jpeg": "image/jpeg",
        ".gif": "image/gif",
        ".svg": "image/svg+xml",
        ".pdf": "application/pdf",
        ".json": "application/json",
        ".csv": "text/csv",
        ".txt": "text/plain",
        ".html": "text/html",
        ".xml": "application/xml",
    }
    return mime_map.get(ext, "application/octet-stream")


class SandboxExecutor:
    """
    Manages ephemeral container execution for sandbox code.
    
    This executor creates Docker containers on-demand, runs code,
    captures output, and destroys the container after execution.
    """
    
    def __init__(
        self,
        config: Optional[SandboxConfig] = None,
        docker_client: Optional[Any] = None,
    ):
        """
        Initialize the sandbox executor.
        
        Args:
            config: Sandbox configuration. If None, loads from deployment config.
            docker_client: Optional Docker client instance. If None, creates one.
        """
        self.config = config or self._load_config()
        self._docker_client = docker_client
        self._client_initialized = False
    
    def _load_config(self) -> SandboxConfig:
        """Load configuration from deployment config."""
        from src.utils.sandbox.config import get_sandbox_config
        return get_sandbox_config()
    
    @property
    def docker_client(self):
        """Lazy-load Docker client."""
        if not self._client_initialized:
            if self._docker_client is None:
                try:
                    import docker
                    self._docker_client = docker.from_env()
                    logger.debug("Docker client initialized")
                except Exception as e:
                    logger.error(f"Failed to initialize Docker client: {e}")
                    raise RuntimeError(
                        "Docker client initialization failed. "
                        "Ensure Docker is running and accessible."
                    ) from e
            self._client_initialized = True
        return self._docker_client
    
    def execute(
        self,
        code: str,
        language: str = "python",
        image: Optional[str] = None,
        timeout: Optional[float] = None,
        limits: Optional[ResourceLimits] = None,
    ) -> SandboxResult:
        """
        Execute code in an ephemeral container.
        
        Args:
            code: The code to execute.
            language: Programming language (python, bash, sh).
            image: Docker image to use. If None, uses default_image.
            timeout: Execution timeout in seconds. If None, uses config default.
            limits: Resource limits. If None, uses config defaults.
        
        Returns:
            SandboxResult with execution output and metadata.
        """
        # Resolve defaults
        image = image or self.config.default_image
        timeout = timeout if timeout is not None else self.config.timeout
        limits = limits or self.config.resource_limits
        
        # Validate image
        if not self.config.is_image_allowed(image):
            return SandboxResult(
                error=f"Image '{image}' is not in the allowlist. "
                      f"Allowed images: {', '.join(self.config.image_allowlist)}",
                exit_code=-1,
            )
        
        # Validate language
        if language not in LANGUAGE_COMMANDS:
            return SandboxResult(
                error=f"Unsupported language '{language}'. "
                      f"Supported: {', '.join(LANGUAGE_COMMANDS.keys())}",
                exit_code=-1,
            )
        
        container = None
        start_time = time.time()
        
        try:
            # Create container
            container = self._create_container(image, limits)
            logger.info(f"Created sandbox container {container.short_id} with image {image}")
            
            # Inject code
            self._inject_code(container, code, language)
            
            # Start container
            container.start()
            
            # Wait for completion with timeout
            result = self._run_with_timeout(container, timeout, language)
            result.execution_time = time.time() - start_time
            
            # Capture output files if execution succeeded
            if not result.error and not result.timed_out:
                try:
                    result.files = self._capture_output_files(container)
                except Exception as e:
                    logger.warning(f"Failed to capture output files: {e}")
            
            return result
            
        except Exception as e:
            logger.error(f"Sandbox execution failed: {e}", exc_info=True)
            return SandboxResult(
                error=f"Execution failed: {str(e)}",
                exit_code=-1,
                execution_time=time.time() - start_time,
            )
        finally:
            # Always cleanup container
            if container:
                self._cleanup_container(container)
    
    def _create_container(self, image: str, limits: ResourceLimits):
        """Create an ephemeral container with resource limits."""
        import docker
        
        # Build container configuration
        container_config = {
            "image": image,
            "command": ["sleep", "infinity"],  # Keep alive until we run code
            "detach": True,
            "mem_limit": limits.memory,
            "nano_cpus": int(limits.cpu * 1e9),  # Convert cores to nanocpus
            "pids_limit": limits.pids_limit,
            "network_mode": "bridge" if self.config.network_enabled else "none",
            "working_dir": "/workspace",
            # Security settings
            "read_only": False,  # Need to write script and outputs
            "security_opt": ["no-new-privileges"],
            # Create tmpfs for workspace
            "tmpfs": {
                "/workspace": f"size=100m,mode=1777",
                "/workspace/output": f"size=50m,mode=1777",
            },
            # Don't auto-remove so we can capture output
            "auto_remove": False,
        }
        
        try:
            container = self.docker_client.containers.create(**container_config)
            return container
        except docker.errors.ImageNotFound:
            # Try to pull the image with registry credentials if configured
            logger.info(f"Image {image} not found locally, pulling...")
            auth_config = self._get_registry_auth(image)
            if auth_config:
                logger.debug(f"Using registry credentials for {auth_config.get('registry', 'default')}")
                self.docker_client.images.pull(image, auth_config=auth_config)
            else:
                self.docker_client.images.pull(image)
            return self.docker_client.containers.create(**container_config)
    
    def _get_registry_auth(self, image: str) -> Optional[Dict[str, str]]:
        """
        Get registry authentication config for an image.
        
        Returns auth_config dict if the image matches the configured registry,
        otherwise returns None.
        """
        if not self.config.registry.is_configured():
            return None
        
        # Check if image is from the configured registry
        registry_url = self.config.registry.url
        
        # Image could be formatted as:
        # - registry.example.com/image:tag
        # - registry.example.com/namespace/image:tag
        if image.startswith(registry_url) or image.startswith(f"{registry_url}/"):
            return self.config.registry.get_credentials()
        
        return None
    
    def _inject_code(self, container, code: str, language: str):
        """Write code to a script file in the container."""
        ext = LANGUAGE_EXTENSIONS.get(language, ".py")
        script_name = f"script{ext}"
        script_path = f"/workspace/{script_name}"
        
        # Create tar archive with the script
        tar_stream = io.BytesIO()
        with tarfile.open(fileobj=tar_stream, mode='w') as tar:
            # Add script file
            script_bytes = code.encode('utf-8')
            script_info = tarfile.TarInfo(name=script_name)
            script_info.size = len(script_bytes)
            script_info.mode = 0o755
            tar.addfile(script_info, io.BytesIO(script_bytes))
        
        tar_stream.seek(0)
        container.put_archive("/workspace", tar_stream)
        logger.debug(f"Injected {len(code)} bytes of {language} code into container")
    
    def _run_with_timeout(
        self,
        container,
        timeout: float,
        language: str,
    ) -> SandboxResult:
        """Run the code with timeout enforcement."""
        import docker
        
        command = LANGUAGE_COMMANDS[language]
        
        try:
            # Execute the command
            exec_result = container.exec_run(
                command,
                workdir="/workspace",
                demux=True,  # Separate stdout and stderr
            )
            
            # Parse output
            stdout_bytes, stderr_bytes = exec_result.output
            stdout = (stdout_bytes or b"").decode("utf-8", errors="replace")
            stderr = (stderr_bytes or b"").decode("utf-8", errors="replace")
            
            # Truncate if needed
            truncated = False
            max_chars = self.config.output_max_chars
            
            if len(stdout) > max_chars:
                stdout = stdout[:max_chars] + f"\n... [truncated at {max_chars} characters]"
                truncated = True
            
            if len(stderr) > max_chars:
                stderr = stderr[:max_chars] + f"\n... [truncated at {max_chars} characters]"
                truncated = True
            
            return SandboxResult(
                stdout=stdout,
                stderr=stderr,
                exit_code=exec_result.exit_code,
                truncated=truncated,
            )
            
        except Exception as e:
            # Check if it was a timeout
            if "timeout" in str(e).lower():
                # Try to get partial output
                try:
                    logs = container.logs(stdout=True, stderr=True).decode("utf-8", errors="replace")
                except Exception:
                    logs = ""
                
                return SandboxResult(
                    stdout=logs,
                    stderr="",
                    exit_code=-1,
                    timed_out=True,
                    error=f"Execution timed out after {timeout} seconds",
                )
            raise
    
    def _capture_output_files(self, container) -> List[FileOutput]:
        """Capture files from /workspace/output/ directory."""
        files = []
        
        try:
            # Get archive of output directory
            bits, stat = container.get_archive("/workspace/output/")
            
            # Extract files from tar
            tar_stream = io.BytesIO()
            for chunk in bits:
                tar_stream.write(chunk)
            tar_stream.seek(0)
            
            with tarfile.open(fileobj=tar_stream, mode='r') as tar:
                for member in tar.getmembers():
                    if not member.isfile():
                        continue
                    
                    # Skip if too large
                    if member.size > self.config.output_max_file_size:
                        logger.warning(f"Skipping large file {member.name} ({member.size} bytes)")
                        files.append(FileOutput(
                            filename=Path(member.name).name,
                            mimetype=_guess_mimetype(member.name),
                            content_base64="",
                            size=member.size,
                            truncated=True,
                        ))
                        continue
                    
                    # Extract and encode
                    f = tar.extractfile(member)
                    if f:
                        content = f.read()
                        files.append(FileOutput(
                            filename=Path(member.name).name,
                            mimetype=_guess_mimetype(member.name),
                            content_base64=base64.b64encode(content).decode("ascii"),
                            size=len(content),
                            truncated=False,
                        ))
            
            logger.debug(f"Captured {len(files)} output files")
            
        except Exception as e:
            # Output directory might not exist or be empty
            if "No such container path" not in str(e) and "404" not in str(e):
                logger.warning(f"Error capturing output files: {e}")
        
        return files
    
    def _cleanup_container(self, container):
        """Force remove the container."""
        try:
            container.remove(force=True)
            logger.debug(f"Removed sandbox container {container.short_id}")
        except Exception as e:
            logger.warning(f"Failed to remove container {container.short_id}: {e}")
    
    def health_check(self) -> bool:
        """
        Check if the sandbox executor is operational.
        
        Returns:
            True if Docker is accessible and sandbox is enabled.
        """
        if not self.config.enabled:
            return False
        
        try:
            self.docker_client.ping()
            return True
        except Exception as e:
            logger.warning(f"Sandbox health check failed: {e}")
            return False
