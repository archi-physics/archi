"""
Sandbox executor for running code in isolated Docker containers.

This module provides the SandboxExecutor class that manages ephemeral container
lifecycle for secure code execution.
"""

from __future__ import annotations

import base64
import io
import os
import tarfile
import tempfile
import time
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Dict, List, Optional

from src.utils.logging import get_logger
from src.utils.sandbox.config import ResourceLimits, SandboxConfig

logger = get_logger(__name__)


# Language to execution command mapping
LANGUAGE_COMMANDS = {
    "python": ["python", "/workspace/script.py"],
    "python3": ["python3", "/workspace/script.py"],
    "bash": ["bash", "/workspace/script.sh"],
    "sh": ["sh", "/workspace/script.sh"],
}

# Language to file extension mapping
LANGUAGE_EXTENSIONS = {
    "python": ".py",
    "python3": ".py",
    "bash": ".sh",
    "sh": ".sh",
}


@dataclass
class FileOutput:
    """Represents a file generated by sandbox execution."""
    
    filename: str
    """Name of the file."""
    
    mimetype: str
    """MIME type of the file."""
    
    content_base64: str
    """Base64-encoded file content."""
    
    size: int
    """Size of the file in bytes."""
    
    truncated: bool = False
    """Whether the file was truncated due to size limits."""


@dataclass
class SandboxResult:
    """Result of a sandbox code execution."""
    
    stdout: str = ""
    """Captured standard output."""
    
    stderr: str = ""
    """Captured standard error."""
    
    exit_code: int = 0
    """Process exit code."""
    
    execution_time: float = 0.0
    """Execution time in seconds."""
    
    files: List[FileOutput] = field(default_factory=list)
    """Generated output files."""
    
    truncated: bool = False
    """Whether stdout/stderr was truncated."""
    
    error: Optional[str] = None
    """Error message if execution failed (not a code error, but system error)."""
    
    timed_out: bool = False
    """Whether execution timed out."""
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "stdout": self.stdout,
            "stderr": self.stderr,
            "exit_code": self.exit_code,
            "execution_time": self.execution_time,
            "files": [
                {
                    "filename": f.filename,
                    "mimetype": f.mimetype,
                    "content_base64": f.content_base64,
                    "size": f.size,
                    "truncated": f.truncated,
                }
                for f in self.files
            ],
            "truncated": self.truncated,
            "error": self.error,
            "timed_out": self.timed_out,
        }


def _guess_mimetype(filename: str) -> str:
    """Guess MIME type from filename extension."""
    ext = Path(filename).suffix.lower()
    mime_map = {
        ".png": "image/png",
        ".jpg": "image/jpeg",
        ".jpeg": "image/jpeg",
        ".gif": "image/gif",
        ".svg": "image/svg+xml",
        ".pdf": "application/pdf",
        ".json": "application/json",
        ".csv": "text/csv",
        ".txt": "text/plain",
        ".html": "text/html",
        ".xml": "application/xml",
    }
    return mime_map.get(ext, "application/octet-stream")


class SandboxExecutor:
    """
    Manages ephemeral container execution for sandbox code.
    
    This executor creates Docker containers on-demand, runs code,
    captures output, and destroys the container after execution.
    """
    
    def __init__(
        self,
        config: Optional[SandboxConfig] = None,
        docker_client: Optional[Any] = None,
    ):
        """
        Initialize the sandbox executor.
        
        Args:
            config: Sandbox configuration. If None, loads from deployment config.
            docker_client: Optional Docker client instance. If None, creates one.
        """
        self.config = config or self._load_config()
        self._docker_client = docker_client
        self._client_initialized = False
    
    def _load_config(self) -> SandboxConfig:
        """Load configuration from deployment config."""
        from src.utils.sandbox.config import get_sandbox_config
        return get_sandbox_config()
    
    @property
    def docker_client(self):
        """Lazy-load Docker client."""
        if not self._client_initialized:
            if self._docker_client is None:
                try:
                    import docker
                    # docker.from_env() automatically reads DOCKER_HOST env var
                    # for Docker-in-Docker, this should be tcp://sandbox-dind:2375
                    docker_host = os.environ.get("DOCKER_HOST", "unix:///var/run/docker.sock")
                    self._docker_client = docker.from_env()
                    logger.debug(f"Docker client initialized (DOCKER_HOST={docker_host})")
                except Exception as e:
                    logger.error(f"Failed to initialize Docker client: {e}")
                    raise RuntimeError(
                        "Docker client initialization failed. "
                        "Ensure Docker/DinD is running and accessible."
                    ) from e
            self._client_initialized = True
        return self._docker_client
    
    def execute(
        self,
        code: str,
        language: str = "python",
        image: Optional[str] = None,
        timeout: Optional[float] = None,
        limits: Optional[ResourceLimits] = None,
    ) -> SandboxResult:
        """
        Execute code in an ephemeral container.
        
        Args:
            code: The code to execute.
            language: Programming language (python, bash, sh).
            image: Docker image to use. If None, uses default_image.
            timeout: Execution timeout in seconds. If None, uses config default.
            limits: Resource limits. If None, uses config defaults.
        
        Returns:
            SandboxResult with execution output and metadata.
        """
        # Resolve defaults
        image = image or self.config.default_image
        timeout = timeout if timeout is not None else self.config.timeout
        limits = limits or self.config.resource_limits
        
        # Validate image
        if not self.config.is_image_allowed(image):
            return SandboxResult(
                error=f"Image '{image}' is not in the allowlist. "
                      f"Allowed images: {', '.join(self.config.image_allowlist)}",
                exit_code=-1,
            )
        
        # Validate language
        if language not in LANGUAGE_COMMANDS:
            return SandboxResult(
                error=f"Unsupported language '{language}'. "
                      f"Supported: {', '.join(LANGUAGE_COMMANDS.keys())}",
                exit_code=-1,
            )
        
        container = None
        start_time = time.time()
        
        try:
            # Create container
            container = self._create_container(image, limits)
            logger.info(f"Created sandbox container {container.short_id} with image {image}")

            # Start container
            container.start()

            # Prepare /workspace & /workspace/output with world-writable perms
            # (runs as root so it works for any image user)
            self._prepare_workspace(container)

            # Inject the user's code
            self._inject_code(container, code, language)
            
            # Wait for completion with timeout
            result = self._run_with_timeout(container, timeout, language)
            result.execution_time = time.time() - start_time
            
            # Capture output files if execution succeeded
            if not result.error and not result.timed_out:
                try:
                    result.files = self._capture_output_files(container)
                except Exception as e:
                    logger.warning(f"Failed to capture output files: {e}")
            
            return result
            
        except Exception as e:
            logger.error(f"Sandbox execution failed: {e}", exc_info=True)
            return SandboxResult(
                error=f"Execution failed: {str(e)}",
                exit_code=-1,
                execution_time=time.time() - start_time,
            )
        finally:
            # Always cleanup container
            if container:
                self._cleanup_container(container)
    
    def _create_container(self, image: str, limits: ResourceLimits):
        """Create an ephemeral container with resource limits.

        The container is configured so that ``/workspace`` and its ``output``
        sub-directory are world-writable (mode 0o777).  This makes the
        executor image-agnostic: it works whether the image runs as root
        (e.g. ``python:3.11-slim``) or as an unprivileged user (e.g.
        ``jupyter/scipy-notebook`` which runs as UID 1000 / ``jovyan``).
        """
        import docker

        # Build container configuration.
        # We do NOT set ``working_dir`` here; the entrypoint script below
        # creates /workspace with the right permissions first, then the
        # actual code execution later uses ``workdir="/workspace"``.
        container_config = {
            "image": image,
            "command": ["sleep", "infinity"],  # Keep alive until we run code
            "detach": True,
            "mem_limit": limits.memory,
            "nano_cpus": int(limits.cpu * 1e9),  # Convert cores to nanocpus
            "pids_limit": limits.pids_limit,
            "network_mode": "bridge" if self.config.network_enabled else "none",
            # Security settings
            "read_only": False,  # Need to write script and outputs
            "security_opt": ["no-new-privileges"],
            # Don't auto-remove so we can capture output
            "auto_remove": False,
        }

        try:
            container = self.docker_client.containers.create(**container_config)
            return container
        except docker.errors.ImageNotFound:
            # Try to pull the image with registry credentials if configured
            logger.info(f"Image {image} not found locally, pulling...")
            auth_config = self._get_registry_auth(image)
            if auth_config:
                logger.debug(f"Using registry credentials for {auth_config.get('registry', 'default')}")
                self.docker_client.images.pull(image, auth_config=auth_config)
            else:
                self.docker_client.images.pull(image)
            return self.docker_client.containers.create(**container_config)

    def _prepare_workspace(self, container) -> None:
        """Create /workspace and /workspace/output with world-writable permissions.

        All commands are executed as **root** so they succeed regardless of the
        image's default user.  The directories are set to mode 0o777 so that
        subsequent code execution (which may run as an unprivileged user) can
        read, write, and create files freely.
        """
        setup_cmds = [
            ["mkdir", "-p", "/workspace/output"],
            ["chmod", "777", "/workspace"],
            ["chmod", "777", "/workspace/output"],
        ]
        for cmd in setup_cmds:
            exit_code, output = container.exec_run(cmd, user="root")
            if exit_code != 0:
                detail = (output or b"").decode("utf-8", errors="replace")
                raise RuntimeError(
                    f"Workspace preparation failed (cmd={cmd!r}, "
                    f"exit_code={exit_code}): {detail}"
                )
    
    def _get_registry_auth(self, image: str) -> Optional[Dict[str, str]]:
        """
        Get registry authentication config for an image.
        
        Returns auth_config dict if the image matches the configured registry,
        otherwise returns None.
        """
        if not self.config.registry.is_configured():
            return None
        
        # Check if image is from the configured registry
        registry_url = self.config.registry.url
        
        # Image could be formatted as:
        # - registry.example.com/image:tag
        # - registry.example.com/namespace/image:tag
        if image.startswith(registry_url) or image.startswith(f"{registry_url}/"):
            return self.config.registry.get_credentials()
        
        return None
    
    def _inject_code(self, container, code: str, language: str):
        """Write code to a script file inside the container.

        The script is packaged in a tar archive and extracted to ``/workspace``.
        Ownership is set to ``0:0`` (root) with mode ``0o755`` so that every
        user in the container can read and execute it.
        """
        ext = LANGUAGE_EXTENSIONS.get(language, ".py")
        script_name = f"script{ext}"

        # Build a tar archive containing the script
        tar_stream = io.BytesIO()
        with tarfile.open(fileobj=tar_stream, mode="w") as tar:
            script_bytes = code.encode("utf-8")
            info = tarfile.TarInfo(name=script_name)
            info.size = len(script_bytes)
            info.mode = 0o755  # world-readable + executable
            info.uid = 0
            info.gid = 0
            tar.addfile(info, io.BytesIO(script_bytes))

        tar_stream.seek(0)
        container.put_archive("/workspace", tar_stream)
        logger.debug(f"Injected {len(code)} bytes of {language} code into container")
    
    def _run_with_timeout(
        self,
        container,
        timeout: float,
        language: str,
    ) -> SandboxResult:
        """Run the code with timeout enforcement."""
        import docker
        
        command = LANGUAGE_COMMANDS[language]
        
        try:
            # Execute the command
            exec_result = container.exec_run(
                command,
                workdir="/workspace",
                demux=True,  # Separate stdout and stderr
            )
            
            # Parse output
            stdout_bytes, stderr_bytes = exec_result.output
            stdout = (stdout_bytes or b"").decode("utf-8", errors="replace")
            stderr = (stderr_bytes or b"").decode("utf-8", errors="replace")
            
            # Truncate if needed
            truncated = False
            max_chars = self.config.output_max_chars
            
            if len(stdout) > max_chars:
                stdout = stdout[:max_chars] + f"\n... [truncated at {max_chars} characters]"
                truncated = True
            
            if len(stderr) > max_chars:
                stderr = stderr[:max_chars] + f"\n... [truncated at {max_chars} characters]"
                truncated = True
            
            return SandboxResult(
                stdout=stdout,
                stderr=stderr,
                exit_code=exec_result.exit_code,
                truncated=truncated,
            )
            
        except Exception as e:
            # Check if it was a timeout
            if "timeout" in str(e).lower():
                # Try to get partial output
                try:
                    logs = container.logs(stdout=True, stderr=True).decode("utf-8", errors="replace")
                except Exception:
                    logs = ""
                
                return SandboxResult(
                    stdout=logs,
                    stderr="",
                    exit_code=-1,
                    timed_out=True,
                    error=f"Execution timed out after {timeout} seconds",
                )
            raise
    
    def _capture_output_files(self, container) -> List[FileOutput]:
        """Capture generated files from the sandbox container.

        Looks in ``/workspace/output/`` first.  If that directory is empty or
        missing, falls back to scanning ``/workspace/`` for common output files
        (images, CSVs, etc.) that the code may have written to the working
        directory instead.
        """
        files = self._extract_files_from_path(container, "/workspace/output/")
        if files:
            logger.info("Captured %d file(s) from /workspace/output/", len(files))
            return files

        # Fallback: scan /workspace/ root for image/data files the code may
        # have saved outside the output directory.
        logger.debug("/workspace/output/ empty or missing; scanning /workspace/ for output files")
        SCAN_EXTENSIONS = {
            ".png", ".jpg", ".jpeg", ".gif", ".svg", ".pdf",
            ".csv", ".json", ".html", ".txt", ".xml",
        }
        fallback_files = self._extract_files_from_path(container, "/workspace/")
        # Filter to only include output-like files (skip the injected script)
        filtered: List[FileOutput] = []
        for f in fallback_files:
            ext = Path(f.filename).suffix.lower()
            if ext in SCAN_EXTENSIONS:
                filtered.append(f)
        if filtered:
            logger.info(
                "Captured %d output file(s) from /workspace/ fallback: %s",
                len(filtered),
                [f.filename for f in filtered],
            )
        else:
            logger.debug("No output files found in /workspace/ fallback either")
        return filtered

    def _extract_files_from_path(
        self, container, path: str
    ) -> List[FileOutput]:
        """Extract regular files from *path* inside the container."""
        files: List[FileOutput] = []
        try:
            bits, stat = container.get_archive(path)

            tar_stream = io.BytesIO()
            for chunk in bits:
                tar_stream.write(chunk)
            tar_stream.seek(0)

            with tarfile.open(fileobj=tar_stream, mode="r") as tar:
                for member in tar.getmembers():
                    if not member.isfile():
                        continue

                    if member.size > self.config.output_max_file_size:
                        logger.warning(
                            "Skipping large file %s (%d bytes)", member.name, member.size
                        )
                        files.append(
                            FileOutput(
                                filename=Path(member.name).name,
                                mimetype=_guess_mimetype(member.name),
                                content_base64="",
                                size=member.size,
                                truncated=True,
                            )
                        )
                        continue

                    f = tar.extractfile(member)
                    if f:
                        content = f.read()
                        filename = Path(member.name).name
                        mimetype = _guess_mimetype(member.name)
                        logger.debug(
                            "Extracted file %s (%s, %d bytes) from %s",
                            filename, mimetype, len(content), path,
                        )
                        files.append(
                            FileOutput(
                                filename=filename,
                                mimetype=mimetype,
                                content_base64=base64.b64encode(content).decode("ascii"),
                                size=len(content),
                                truncated=False,
                            )
                        )

        except Exception as e:
            err_str = str(e)
            if "No such container path" not in err_str and "404" not in err_str:
                logger.warning("Error capturing files from %s: %s", path, e)
            else:
                logger.debug("Path %s does not exist in container (expected)", path)

        return files
    
    def _cleanup_container(self, container):
        """Force remove the container."""
        try:
            container.remove(force=True)
            logger.debug(f"Removed sandbox container {container.short_id}")
        except Exception as e:
            logger.warning(f"Failed to remove container {container.short_id}: {e}")
    
    def health_check(self) -> bool:
        """
        Check if the sandbox executor is operational.
        
        Returns:
            True if Docker is accessible and sandbox is enabled.
        """
        if not self.config.enabled:
            return False
        
        try:
            self.docker_client.ping()
            return True
        except Exception as e:
            logger.warning(f"Sandbox health check failed: {e}")
            return False
